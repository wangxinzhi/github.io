<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java学习（基础） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java基础语法 继承 super()   变量声明必须初始化 Java中整数默认int类型，浮点数默认double类型 Java中的访问修饰符 public：可以被所有其他类访问 protected：可以被自身、子类及同一个包中的类可以访问 private：只能被自己访问、修改 default：可以被同一个包中的类访问   == 可以用于基本类型和引用类型 基本类型：比较值 引用类型：比较引用">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习（基础）">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;10&#x2F;24&#x2F;Java%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java基础语法 继承 super()   变量声明必须初始化 Java中整数默认int类型，浮点数默认double类型 Java中的访问修饰符 public：可以被所有其他类访问 protected：可以被自身、子类及同一个包中的类可以访问 private：只能被自己访问、修改 default：可以被同一个包中的类访问   == 可以用于基本类型和引用类型 基本类型：比较值 引用类型：比较引用">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-24T10:35:12.407Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java学习（基础）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/24/Java%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" class="article-date">
  <time datetime="2019-10-24T10:35:12.000Z" itemprop="datePublished">2019-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java学习（基础）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><ol>
<li>继承<ul>
<li>super()</li>
</ul>
</li>
<li>变量声明必须初始化</li>
<li>Java中整数默认int类型，浮点数默认double类型</li>
<li>Java中的访问修饰符<ul>
<li>public：可以被所有其他类访问</li>
<li>protected：可以被自身、子类及同一个包中的类可以访问</li>
<li>private：只能被自己访问、修改</li>
<li>default：可以被同一个包中的类访问</li>
</ul>
</li>
<li>== 可以用于基本类型和引用类型<ul>
<li>基本类型：比较值</li>
<li>引用类型：比较引用对象</li>
</ul>
</li>
<li>方法重写和重载<ul>
<li>重写（override）：满足三同一大一小（方法名、返回值、形参相同；访问权限&gt;=重写前；抛出异常&lt;=重写前）</li>
<li>重载（overload）：<ul>
<li>Java允许一个类里定义多个同名方法，只要形参列表（参数个数和参数类型）不同就行，与返回值无关与权限访问修饰符无关</li>
<li>在调用重载的方法时通过传递给他们不同的参数个数和参数类型来决定具体使用哪个方法，这叫多态</li>
</ul>
</li>
</ul>
</li>
<li>final<ul>
<li>final 变量<ul>
<li>final 声明基本数据类型：显示初始化且只能被初始化一次</li>
<li>final 声明引用类型变量：引用不能指向不同的对象，但是对象的值可以改变</li>
</ul>
</li>
<li>final 方法<ul>
<li>类中的方法可以被子类继承但是不可以被子类修改（申明 final 方法的目的在于防止方法的内容被修改）</li>
</ul>
</li>
<li>final 类<ul>
<li>final 类不能被继承，没有类能继承 final 类的任何特性</li>
</ul>
</li>
</ul>
</li>
<li>instanceof 判断前者是否可以转化为后者</li>
<li>类的初始化过程<ul>
<li>初始化父类中的静态成员变量和静态代码，按程序中出现的顺序初始化</li>
<li>初始化子类中的静态成员变量和静态代码，按程序中出现的顺序初始化</li>
<li>初始化父类的普通成员变量和代码块，再执行父类的构造函数</li>
<li>初始化子类的普通成员变量和代码块，再执行子类的和构造函数</li>
</ul>
</li>
<li>数组的复制方法：<ul>
<li>复制的效率：System.arrarycopy &gt; clone &gt; Arrary.copyOf &gt; for 循环</li>
</ul>
</li>
<li>在线程B中调用线程A的join方法，直到线程A执行完成后才会继续执行线程B</li>
<li>在Java中检测两个浮点数是否相等需要格外小心<ul>
<li>eg：0.1 * 3 != 0.3</li>
</ul>
</li>
<li>所有的Java对象都要在队中构造</li>
<li>显示参数和隐士参数<ul>
<li>在每一个方法中，关键字 this 表示隐式参数</li>
</ul>
</li>
<li>关键字 this 两个用途：<ul>
<li>引用隐式参数</li>
<li>调用该类的其他构造器</li>
</ul>
</li>
<li>关键字 super 的两个用途<ul>
<li>调用超类的方法</li>
<li>调用超类的构造器</li>
</ul>
</li>
<li>多态<ul>
<li>可以将子类的对象赋给超类的对象</li>
<li>在Java中对象变量是多态的</li>
<li>声明什么用什么</li>
</ul>
</li>
<li>内联<ul>
<li>eg：e.getName()将被替换为访问e.name域</li>
</ul>
</li>
<li>Abstract 修饰的抽象类<ul>
<li>一般修饰类和方法</li>
</ul>
</li>
<li>接口<ul>
<li>接口不是类，不能被实例化</li>
<li>可以声明一个接口变量并指向实现接口的类对象</li>
<li>接口中的方法自动是 public 的；接口中不能存在实例域/静态方法，但是可以包含常量，接口中的域被自动设置为public static final</li>
<li>有些接口中只是定义了常量而没有定义方法 实现接口的类都将自动继承这些常量</li>
<li>接口中的变量默认是public static final</li>
<li>接口中的方法默认是public abstract</li>
</ul>
</li>
<li>内部类<ul>
<li>作用<ul>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li>
<li>内部类可以对同包中的其他隐藏起来</li>
<li>当想要定义一个回调函数且不想编写大量代码，使用匿名内部类比较便捷</li>
</ul>
</li>
<li>限制<ul>
<li>内部类中声明的所有静态域都必须是 final 的</li>
<li>内部类不能有 static 方法 （ 注：Java语法规范对于这个限制没有做出任何的解释 ）</li>
<li>在内部类不需要访问外围类对象的时候应该使用静态内部类，与常规的内部类不同静态内部类可以拥有静态域和方法</li>
</ul>
</li>
<li>局部内部类<ul>
<li>局部内部类：方法只引用定义为 final 的局部变量</li>
<li>匿名内部类：<ul>
<li>局部内部类的更深入一步，假如只创建这个类的一个对象，就不必命名，即为匿名内部类</li>
<li>匿名内部类无构造函数</li>
<li>语法格式<ul>
<li><pre><code>New superType( construction parameters ) {
  Inter class methods and data;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">            + 作用：Java程序员习惯的做法是用匿名内部类实现实现事件监听器和其他回调（但是如今最好还是用lambda表达式）</span><br><span class="line">    + 静态内部类</span><br><span class="line">22. Lambda 表达式</span><br><span class="line">    + 重点在于延迟执行，结合接口可以用于回调函数的编写</span><br><span class="line">23. 泛型</span><br><span class="line">    + 泛型类</span><br><span class="line">        + 可以有多个类型变量</span><br><span class="line">    + 泛型方法</span><br><span class="line">        + 泛型方法可以定义在普通类中也可以定义在泛型类中</span><br><span class="line">    + 类型变量</span><br><span class="line">        + 使用大写形式 eg: T</span><br><span class="line">        + 类型变量的限定用extends</span><br><span class="line">    + 类型擦除</span><br><span class="line">        + 擦除类型变量，并替换为限定类型（无限的变量用object）</span><br><span class="line">24. 集合</span><br><span class="line">    + 集合有两个基本接口</span><br><span class="line">        + Collection 接口：集合类的基本接口是Collection接口，这个接口有两个基本方法：add 和 iterator</span><br><span class="line">		    + List</span><br><span class="line">			    + 是一个有序集合</span><br><span class="line">				+ 有序且可重复</span><br><span class="line">			+ Set</span><br><span class="line">				+ 无序且不可重复</span><br><span class="line">				+ 等同于Collection接口</span><br><span class="line">			+ Queue</span><br><span class="line">        + Map 接口</span><br><span class="line">    + 常用的几种集合特性总结</span><br><span class="line">        + Arrarylist</span><br><span class="line">			+ 底层是数组</span><br><span class="line">			+ 默认初始化大小为10 每次扩容是原来的1.5倍</span><br><span class="line">		+ Linkedlist</span><br><span class="line">			+ 实现list接口和deque接口的双端链表</span><br><span class="line">		+ Hashset</span><br><span class="line">			+ 基于hashmap实现，底层采用hashmap来保存元素</span><br><span class="line">		+ Hashmap</span><br><span class="line">			+ 非同步，线程不安全</span><br><span class="line">			+ 可以null键和null值</span><br><span class="line">			+ 默认初始值大小为16 （1 &lt;&lt; 4 ） ，  阈值默认为8 链表长度大于阈值时链表转化为红黑树以此来减少搜索时间</span><br><span class="line">			+ 扩容规则为原来的2倍</span><br><span class="line">			+ 底层实现 数组和链表/红黑二叉树 即 链表散列</span><br><span class="line">			+ 为什么初始值是2的倍数，扩容机制是2的幂次</span><br><span class="line">			    + 在hashmap的源码中，put方法会调用indexFor（int hash， int length）方法来定位值所要存放的位置，而这个方法的具体实现是hash &amp; （length - 1），容量是2的幂次可以使添加的元素均匀分布在hashmap中的数组上，减少hash碰撞。</span><br><span class="line">		+ Concurrenthashmap</span><br><span class="line">			+ 底层实现 数组+链表/红黑二叉树</span><br><span class="line">			+ 线程安全</span><br><span class="line">		+ Hashtable</span><br><span class="line">			+ 线程安全</span><br><span class="line">			+ 不可以有null键</span><br><span class="line">			+ 默认初始值大小为11</span><br><span class="line">			+ 扩容规则为原来的2n + 1</span><br><span class="line">25. 克隆</span><br><span class="line">    + clone是object方法，不是Cloneable接口的方法，Cloneable接口是一个标记接口</span><br><span class="line">	+ 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址</span><br><span class="line">	+ 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址</span><br><span class="line">		+ 重写clone函数</span><br><span class="line">			+ clone函数的嵌套调用</span><br><span class="line">			+ 序列化</span><br><span class="line">26. 数组</span><br><span class="line">    + Arrarys.copyOf（arraryname,  length） 这个方法通常用来增加数组大小</span><br><span class="line">	+ 数组排序：</span><br><span class="line">		+ Arrarys.sort（）用了优化的快速排序</span><br><span class="line">27. 静态</span><br><span class="line">    + 静态域</span><br><span class="line">    + 静态方法：不能访问实例域，只能访问静态域</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 并发同步</span><br><span class="line"></span><br><span class="line">1. 线程有6种状态</span><br><span class="line">	+ New 新创建</span><br><span class="line">    + Runnable 可运行</span><br><span class="line">	+ Blocked 被阻塞</span><br><span class="line">	+ Waitting 等待</span><br><span class="line">	+ Timed waitting 计时等待</span><br><span class="line">	+ Terminated 被终止</span><br><span class="line">2. 线程优先级</span><br><span class="line">    + 默认继承父线程优先级</span><br><span class="line">3. 守护线程</span><br><span class="line">    + 唯一用途为其他线程提供服务</span><br><span class="line">    + 在线程启动之前调用 setDaemon 可以将线程设置为守护线程</span><br><span class="line">4. 为捕获异常处理器</span><br><span class="line">    + run中抛出的异常不会被外界捕获直接抛出给 System.err 想要捕获异常要实现一个Thread.UnCaughtExceptionHandler类</span><br><span class="line">5. 同步</span><br><span class="line">    + Synchronized 关键字</span><br><span class="line">		+ Java每个对象都有一个内部锁</span><br><span class="line">		+ 内部锁只有一个条件对象</span><br><span class="line">		+ 条件用的是 wait、notifyAll、以及notify方法</span><br><span class="line">		+ 同步方法 ：使用同步方法调用锁</span><br><span class="line">			+ 将静态方法声明为synchronized也是合法的</span><br><span class="line">		+ 同步阻塞：使用同步阻塞也可以获得锁 不推荐使用</span><br><span class="line">	+ 使用锁 （lock）和条件 （condition）对象</span><br><span class="line">		+ ReentrantLock 保护代码块的基本结构</span><br><span class="line">			+</span><br></pre></td></tr></table></figure>
Mylock.lock(); // an ReentrantLock object
Try {
  Critical section;
}
Finally {
  Mylock.unlock(); // make sure the lock is unlocked even if an exception is thrown
}</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>临界区<ul>
<li>多线程修改共享资源的代码区</li>
</ul>
</li>
<li>锁是可重入的 锁保持一个持有计数来跟踪对于lock方法的嵌套调用</li>
<li>条件对象<ul>
<li>一个锁对象可以有一个或是多个条件对象</li>
<li>可以通过lock.newCondition方法来获取一个条件对象</li>
<li>Mycondition.wait() 线程处于被阻塞状态，进入该条件的等待集  mycondition.signalAll方法通知正在等待的线程： 此时有可能已经满足条件，值得再次去检测该条件</li>
</ul>
</li>
<li>当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用await、signalAll或是signal方法</li>
<li>阻塞队列</li>
<li>使用阻塞队列时，程序员就不必考虑同步问题</li>
<li>并行流</li>
<li>同步监视器 == 同步代码块</li>
<li>Volatile 修饰实例域<ul>
<li>volatile变量不能提供原子性</li>
<li>变量除赋值外不完成其他操作可以将共享变量声明为volatile</li>
</ul>
</li>
</ul>
</li>
<li>继承Thread类</li>
<li>实现runnable接口</li>
<li>实现callable接口<ul>
<li>callable介绍</li>
<li>callable接口实现多线程的应用场景</li>
<li>callable接口实现多线程的步骤<ul>
<li>创建实现callable接口的实例化对象</li>
<li>创建FutureTask对象，将callable放入FutureTask中</li>
<li>创建Thread对象，将FutureTask对象放入Thread对象</li>
<li>启动线程</li>
</ul>
</li>
</ul>
</li>
<li>线程池<ul>
<li>Executor 执行器类有许多静态工厂方法用来构建线程池</li>
</ul>
</li>
</ol>
<hr>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><hr>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><hr>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>数据库规范<ul>
<li>所有数据库对象名称必须使用 小写字母 并用 下划线 分割</li>
<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>临时库表必须以 tmp_ 为前缀并以日期为后缀，备份表必须以 bak_ 为前缀并以日期 (时间戳) 为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
</li>
<li>MySQL数据库<ul>
<li>优化<ul>
<li>限定数据的范围 禁止不带任何限制数据范围条件的查询语句 比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内</li>
<li>读/写分离 经典的数据库拆分方案 主库负责写 从库负责读</li>
<li>垂直分区 数据表列的拆分，把一张列比较多的表拆分为多张表<ul>
<li>垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂</li>
</ul>
</li>
<li>水平分区</li>
</ul>
</li>
<li>视图的作用<ul>
<li>视图隐藏了底层的表结构，简化了数据访问操作，客户端不再需要知道底层表的结构及其之间的关系</li>
<li>视图提供了一个统一访问数据的接口。（即可以允许用户通过视图访问数据的安全机制，而不授予用户直接访问底层表的权限）</li>
<li>从而加强了安全性，使用户只能看到视图所显示的数据</li>
<li>视图还可以被嵌套，一个视图中可以嵌套另一个视图</li>
</ul>
</li>
<li>MySQL中，有三种主要的类型：Text（文本），Number（数字）和Date/Time（日期/时间）类型<ul>
<li>Text</li>
<li>Number</li>
<li>Date</li>
</ul>
</li>
<li>MySQL使用下列数据类型在数据库中存储日期或日期/时间值<ul>
<li>DATE - 格式：YYYY-MM-DD</li>
<li>DATETIME - 格式：YYYY-MM-DD HH:MM:SS</li>
<li>TIMESTAMP - 格式：YYYY-MM-DD HH:MM:SS</li>
<li>YEAR - 格式：YYYY 或 YY</li>
</ul>
</li>
</ul>
</li>
<li>JDBC 数据库的连接方式<ul>
<li>DriverManager 传统的方式</li>
<li>DataSource Javax.sql.DataSource接口，作为DiriverManager替代</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Servlet学习笔记"><a href="#Servlet学习笔记" class="headerlink" title="Servlet学习笔记"></a>Servlet学习笔记</h2><ol>
<li>tomcat只是一个web容器 / apache 是一个HTTP服务器，解析静态html</li>
<li>tcp端口<ul>
<li>只是一个数字，一个16位数</li>
<li>用于标识服务器硬件上一个特定的软件程序</li>
<li>端口表示与服务器硬件上运行的一个特定软件的逻辑连接</li>
</ul>
</li>
<li>web服务器<ul>
<li>web服务器应用擅长提供静态web页面，只提供静态页面</li>
<li>CGI和servlet扮演web服务器辅助应用的角色，提供动态页面</li>
</ul>
</li>
<li>web容器<ul>
<li>web服务器应用（如： Apache）得到一个指向某个Servlet的请求，此时服务器不是把这个请求交给servlet本身，而是交给部署该servlet的容器。由容器向servlet提供HTTP请求与响应</li>
<li>容器提供：<ul>
<li>通信支持</li>
<li>生命周期管理</li>
<li>多线程支持</li>
<li>生命方式实现安全</li>
<li>JSP支持</li>
</ul>
</li>
<li>容器启动<ul>
<li>寻找已经部署的web应用，然后开始搜索servlet文件</li>
<li>加载类</li>
</ul>
</li>
</ul>
</li>
<li>J2EE 是一种超级规范，他结合了其他一些规范</li>
<li>Servlet 详解：<ul>
<li>关键API: &lt;<interface>&gt; javax.servlet.Servlet &lt;—- javax.servlet.GenericServlet（抽象类，实现了大部分方法） &lt;—- javax.servlet.http.HttpServlet（抽象类，实现了service（）方法） </li>
<li>Servlet 生命周期<ul>
<li>web容器读取DD文件</li>
<li>ServletContext<ul>
<li>容器为应用创建一个新的ServletContext</li>
<li>为每个初始化参数创建一个String名/值对</li>
<li>将名/值参数引用交给ServletContext</li>
</ul>
</li>
<li>创建Listener监听器</li>
<li>web容器加载servlet类</li>
<li>web容器初始化servlet对象，无参构造函数运行<ul>
<li>容器初始化一个servlet时会为它创建一个唯一的ServetConfig</li>
<li><ol>
<li>容器从DD中读取servlet初始化参数 <ol start="2">
<li>创建一个ServletConfig实例</li>
<li>并把参数交给ServletConfig，然后把ServletConfig传递给servlet的init（ServletConfig）方法</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>Init（）调用，servlet一生中只调用一次，且必须在service之前完成，可能也可以去覆盖</li>
<li>service（），不也不太可能去覆盖</li>
<li>destory（）</li>
</ul>
</li>
<li>servlet实例<ul>
<li>每1个JVM都会有特定servlet的1个实例</li>
<li>每1个web应用有1个ServletContext实例</li>
<li>每1个servlet有1个ServletConfig实例</li>
</ul>
</li>
</ul>
</li>
<li>Listener 监听者<ul>
<li>Javax.servlet.ServletContextListener（interface）监听ServletContext的初始化和撤销</li>
</ul>
</li>
<li>对于tomcat这样的web容器来说客户端的每一个请求是一个新的线程</li>
<li>session<ul>
<li>对于客户的第一个请求，容器会生成一个唯一的session id，并通过响应把他返回给客户，客户在以后的每一个请求中都会发回这个session id；容器看到session id后找到匹配的会话，并把会话与请求相关联</li>
<li>客户和容器交换session id的方式：最简单和最常用的交换方式可以通过cookies交换session id信息</li>
<li>开发人必须（也只需要）告诉容器想要创建或者使用一个会话（eg：request.getSession()），除此之外生成session id、创建一个新的cookie对象、把session id放在cookie中、把cookie设置为响应的一部分等工作都是由容器负责</li>
<li>对于客户端拒绝cookie的情况，可以使用URL重写来存储session id</li>
</ul>
</li>
<li>一个JVM只有一个ServletContext，每一个servlet有一个ServletConfig</li>
</ol>
<hr>
<h2 id="实际开发中需要注意的几个点"><a href="#实际开发中需要注意的几个点" class="headerlink" title="实际开发中需要注意的几个点"></a>实际开发中需要注意的几个点</h2><ol>
<li>equals<ul>
<li>正确使用equals函数<ul>
<li>Object的equals方法容易抛出空指针异常，应该使用常量或者是确定有值的对象来调用equals</li>
<li>更加推荐使用 Java.util.Objects#equals（jdk 1.7 引入的工具类）推荐的原因见源码</li>
</ul>
</li>
</ul>
</li>
<li>整形包装类值的比较<ul>
<li>图</li>
</ul>
</li>
<li>BigDecimal<ul>
<li>BigDecimal 在使用时为了防止精度丢失，推荐使用它的BigDecimal（String）构造方法来创建对象或者使用ValueOf方法，此方法内部就是执行了double.toString()</li>
</ul>
</li>
<li>基本数据类型和包装数据类型的使用标准<ul>
<li>【强制】 所有POJO类属性必须使用包装数据类型</li>
<li>【强制】 RPC方法的返回值和参数必须使用包装数据类型</li>
<li>【推荐】 所有的局部变量使用基本数据类型</li>
</ul>
</li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/24/Java%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" data-id="ck24l0o8i0009skaddj1sfc8t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/10/23/Git%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Git笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/24/Java%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">Java学习（基础）</a>
          </li>
        
          <li>
            <a href="/2019/10/23/Git%E7%AC%94%E8%AE%B0/">Git笔记</a>
          </li>
        
          <li>
            <a href="/2019/10/23/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>